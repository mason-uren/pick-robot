#ifndef PICKERROBOT_STEPPERMOTOR_H
#define PICKERROBOT_STEPPERMOTOR_H

#include <ConfigStruct.h>
#include <SharedMemoryStructs.h>

#include "MotorInterface.h"
#include "../PinInteractions/StatusRegister.h"
#include "../../Software/ErrorHandler/ErrorHandler.h"

class SlushMotor;

/**
 * @class StepperMotor
 * @brief A physical implementation of a #MotorInterface.
 *
 * The job of the stepper motor is to move in the desired direction or to a set location, at a pre-set or given speed,
 *  till an event occurs; the defining event may be completion of task, error state triggers
 *  emergency stop, or another overriding functionality. The stepper motor has the ability
 *  to move anywhere within the designated axis limits, change speed and/or #STEP_STYLE, return
 *  to a set home location, all while handling errors that may occur, in realtime. Direction motor communication
 *  is processed using the L6470 microstepping motor controller, specific to each motor on the
 *  SlushBoard.
 */
class StepperMotor : public MotorInterface {
public:
	/**
	 * @param[in] motorConfig A reference to how the motor should be configured.
	 */
	StepperMotor(MOTOR_CONFIG * motorConfig);
	~StepperMotor();

	/**
	 * @fn step
	 * @brief Check for any errors, specific to the motor.
	 *
	 * Errors being reported are generated by the l6470 microstepping motor controller
	 *  and are logged using the  ErrorHandler::addError.
	 * @param[in] clockTicks The current clock tick in milliseconds.
	 */
	void step(long long int clockTicks);

	/**
	 * @fn reportStatus
	 * @brief Check the SlushBoard status, specific to the motor, and report
	 * 	to #ROBOT_OUT.
	 * @param[in] robotOutPtr A reference to #ROBOT_OUT.
	 */
	void reportStatus(void *robotOutPtr);

	/**
	 * @fn emergencyStop
	 * @brief Immediately stop all motor motion.
	 */
	void emergencyStop();

    bool reachedTarget();
    void move(long steps);
	void goTo(axis_pos position);
	void goTo(axis_pos position, int stepsPerSec);
	double getMMPerRev() {
		return mmPerRev;
	}
	int getPositionInSteps();
	void zeroReturn(DIRECTION dir);
    void setHome();
	void hardStop();
	void softStop();
	axis_pos getPositionInMM();
	int getStepsPerRev() {
		return stepsPerRev;
	}
	void updateConfig(MOTOR_CONFIG * motorConfig);
	void setSpeed(double speed);
	double getMaxSpeed();
	double mmToSteps(long desiredDist);
	void goToHome();
	void moveOffOfLimitSwitches(long steps);

	/**
	 * @fn microstepsToSteps
	 * @brief Translate a give number of micro-steps into full steps.
	 * @param[in] microsteps The number of microsteps.
	 * @return Full steps.
	 */
	int microstepsToSteps(int microsteps);

	/**
	 * @fn isLimitSwitchDepressed
	 * @brief Check whether the limit switch, specific to the motor, is depressed.
	 * @return Has the limit switch been depressed by the corresponding stepper-motor.
	 */
	bool isLimitSwitchDepressed();

	/**
	 * @fn setSteppingMode
	 * @param[in] mode The desired stepping style.
	 */
	void setSteppingMode(STEP_STYLE mode);

	/**
	 * @fn stepsToMicroSteps
	 * @brief Translate a give number of full steps into micro-steps.
	 * @param[in] steps The number of full steps.
	 * @return Micro-steps.
	 */
	int stepsToMicroSteps(int steps);

	/**
	 * @fn invertDirection
	 * @brief Translates desired motor direction into SlushMotor direction.
	 * @param[in] dir The current direction of motion.
	 * @return The opposite direction.
	 */
	DIRECTION invertDirection(DIRECTION dir);

private:
	int maxStepsPerSec;				/**< The designated maximum steps/second the motor can travel. */
	SlushMotor* motor;				/**< A reference to the SlushMotor.h library */
	double mmPerRev;				/**< The required number of millimeters to travel before completing a full motor revolution. */
    long stepsPerRev;				/**< The required number of steps to take before completing a full revolution. */
    int invert;						/**< Flag that determines if motor motions are reversed. */
    StatusRegister statusRegister;	/**< The status of the current motor as reported from SlushBoard.h */
};


#endif //PICKERROBOT_STEPPERMOTOR_H
